#!/usr/bin/env python

#USB Mass Storage Emulator
#by Travis Goodspeed
#with thanks to Brandon Wilson and his Linky project.

import sys;
import binascii;
import array;
import time;

from GoodFETMAXUSB import *;

class GoodFETMAXUSBMass(GoodFETMAXUSB):
    """This emulates a USB Mass Storage device."""
    def massinit(self):
        """Initialize a USB Mass Storage device."""
        self.usb_disconnect();
        time.sleep(1);
	self.usb_connect();
        self.massrun();
        
    def massrun(self):
        """Main loop of the USB Mass Storage emulator."""
        print "Starting a Mass Storage device.  This doesn't work yet.";
        while 1:
            self.service_irqs();
    def do_SETUP(self):
        """Handle USB Enumeration"""
        
        #Grab the SETUP packet from the buffer.
        SUD=self.readbytes(rSUDFIFO,8);
        
        #Parse the SETUP packet
        print "Handling a setup packet of %s" % self.setup2str(SUD);
        setuptype=(ord(SUD[bmRequestType])&0x60);
        if setuptype==0x00:
            self.std_request(SUD);
        elif setuptype==0x20:
            self.class_request(SUD);
        elif setuptype==0x40:
            self.vendor_request(SUD);
        else:
            print "Unknown bmRequestType=0x%02x." % ord(SUD[bmRequestType])
            self.STALL_EP0(SUD);
    def class_request(self,SUD):
        """Handle a class request."""
        requesttype=ord(SUD[bmRequestType]);
        request=ord(SUD[bRequest]);
        if requesttype==0xA1 and request==0xFE:
            print "Reporting 0 as the maximum LUN.";
            #This is a Get Max LUN request.
            #Return 1-byte maximum Logical Unit Number
            self.wreg(rEP0FIFO,0x00); # Just one LUN.
            self.wregAS(rEP0BC,1); # ARM and fire!
            return; #Don't stall.
        if requesttype==0x21 and request==0xff:
            print "Received BBB reset."
            self.wregAS(rEP0BC,0); # ARM and fire!
            return; #Don't stall.
        print "Stalling an unknown class request: %s" % self.setup2str(SUD);
        self.STALL_EP0(SUD);
    def vendor_request(self,SUD):
        """Handle a vendor request."""
        request=ord(SUD[bRequest]);
        print "Why the hell is there a vendor request?";
        #self.wreg(rEP0FIFO,0);
        self.wregAS(rEP0BC,0);
    def std_request(self,SUD):
        """Handles a standard setup request."""
        setuptype=ord(SUD[bRequest]);
        if setuptype==SR_GET_DESCRIPTOR: self.send_descriptor(SUD);
        #elif setuptype==SR_SET_FEATURE: self.feature(1);
        elif setuptype==SR_SET_CONFIGURATION: self.set_configuration(SUD);
        elif setuptype==SR_GET_STATUS: self.get_status(SUD);
        elif setuptype==SR_SET_ADDRESS: self.rregAS(rFNADDR);
        elif setuptype==SR_GET_INTERFACE: self.get_interface(SUD);
        else:
            #print "Stalling Unknown standard setup request type %02x" % setuptype;
            #self.STALL_EP0(SUD);
            print "Accepting unknown standard setup request type %02x" % setuptype;
            self.wregAS(rEP0BC,0);
            
    def get_interface(self,SUD):
        """Handles a setup request for SR_GET_INTERFACE."""
        if ord(SUD[wIndexL]==0):
            self.wreg(rEP0FIFO,0);
            self.wregAS(rEP0BC,1);
        else:
            self.STALL_EP0(SUD);
    


#Device Descriptor
    DD=[ 
        
    0x12, #length
    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40,
    0x81, 0x07, #Sandisk 
    0x50, 0x51, #SDCZ2 Cruzer Mini Flash Drive (thin)
    0x00, 0x03, 0x00, 0x00, 0x00, 0x01
    
    ];

#Configuration Descriptor
    CD=[

  0x09, #Length
  0x02, #Type
  0x20, #Total Length
  0x00, 0x01, 0x01, 0x00, 0xE0, 0x00, 0x09, 0x04, 0x00, 0x00,
  0x02, #Num Endpoints
  0x08, #Mass Storage Bulk Only
  0x06, #SCSI
  0x50, 0x00,
  
  #OUT EP1
  0x07, 0x05, 0x01, 0x02, 0x40, 0x00, 0x00,
  #IN EP3
  0x07, 0x05, 0x83, 0x02, 0x40, 0x00, 0x00,

];
    strDesc=[
# STRING descriptor 0--Language string
"\x04\x03\x09\x04",
# [
#         0x04,			# bLength
# 	0x03,			# bDescriptorType = string
# 	0x09,0x04		# wLANGID(L/H) = English-United Sates
# ],
# STRING descriptor 1--Manufacturer ID
"\x10\x03G\x00o\x00o\x00d\x00F\x00E\x00T\x00",
# STRING descriptor 2 - Product ID
"\x1C\x03M\x00A\x00S\x00S\x00 \x00E\x00m\x00u\x00l\x00a\x00t\x00o\x00r\x00",
# STRING descriptor 3 - Serial Number ID
"\x14\x03S\x00/\x00N\x00 \x003\x004\x002\x000\x00E\x00"
];

    def send_descriptor(self,SUD):
        """Send the USB descriptors based upon the setup data."""
        desclen=0;
        reqlen=ord(SUD[wLengthL])+256*ord(SUD[wLengthH]); #16-bit length
        desctype=ord(SUD[wValueH]);
        
        if desctype==GD_DEVICE:
            desclen=self.DD[0];
            ddata=self.DD;
        elif desctype==GD_CONFIGURATION:
            desclen=self.CD[2];
            ddata=self.CD;
        elif desctype==GD_STRING:
            desclen=self.strDesc[ord(SUD[wValueL])][0];
            ddata=self.strDesc[ord(SUD[wValueL])];
        
        #TODO Configuration, String, Hid, and Report
        
        if desclen>0:
            sendlen=min(reqlen,desclen);
            self.writebytes(rEP0FIFO,ddata);
            self.wregAS(rEP0BC,sendlen);
        else:
            print "Stalling in send_descriptor() for lack of handler for %02x." % desctype;
            self.STALL_EP0(SUD);
    def set_configuration(self,SUD):
        """Set the configuration."""
        bmSUSPIE=0x10;
        configval=ord(SUD[wValueL]);
        if(configval>0):
            self.SETBIT(rUSBIEN,bmSUSPIE);
        self.rregAS(rFNADDR);
    def get_status(self,SUD):
        """Get the USB Setup Status."""
        testbyte=ord(SUD[bmRequestType])
        
        #Toward Device
        if testbyte==0x80:
            self.wreg(rEP0FIFO,0x03); #Enable RWU and self-powered
            self.wreg(rEP0FIFO,0x00); #Second byte is always zero.
            self.wregAS(rEP0BC,2);    #Load byte count, arm transfer, and ack CTL.
        #Toward Interface
        elif testbyte==0x81:
            self.wreg(rEP0FIFO,0x00);
            self.wreg(rEP0FIFO,0x00); #Second byte is always zero.
            self.wregAS(rEP0BC,2);
        #Toward Endpoint
        elif testbyte==0x82:
            if(ord(SUD[wIndexL])==0x83):
                print "This code almost certainly doesn't work.";
                self.wreg(rEP0FIFO,0x01); #Stall EP3
                self.wreg(rEP0FIFO,0x00); #Second byte is always zero.
                self.wregAS(rEP0BC,2);
            else:
                self.STALL_EP0(SUD);
        else:
            self.STALL_EP0(SUD);
    
    def do_IN3(self):
        """Handle IN3 input event."""
        #Don't bother clearing interrupt flag, that's done by sending the reply.
        print "Got an input event, no idea what to do about it.";
        #This would be for FTDI emulation.  Not for Mass Storage.
        #self.wreg(rEP3INFIFO,0x01);      #Modem 
        #self.wreg(rEP3INFIFO,0x00);      #Line 
        #self.wreg(rEP3INFIFO,0x00);
        self.wregAS(rEP3INBC,0);
        
        
    def do_OUT1(self):
        """Handle an OUT1 output event."""
        print "Got an output event, printing the result.";
        l=self.rreg(rEP1OUTBC);
        frame=self.readbytesAS(rEP1OUTFIFO,l);
        self.handleCBW(frame);
    lastCBW="";
    def handleCBW(self,cbw):
        """Handles an incoming Command Block Wrapper.  See USB Mass
        Storage Class for details."""
        
        if len(cbw)!=31:
            print "Invalid CBW length of %i bytes.  Aborting." % len(cbw);
        sig=cbw[0:4];
        if sig!="USBC":
            print "Invalid CBW signature: %s.  Should be USBC; aborting." % sig;
            return;
        self.lastCBW=cbw;
        
        dtlen=ord(cbw[8])+(ord(cbw[9])<<8)+(ord(cbw[10])<<16)+(ord(cbw[11])<<24);
        flags=ord(cbw[12]);
        dtdir=flags&0x80; # 0x80 for dev->host, 0x00 for host->dev
        lun=ord(cbw[13])&0x0F; # Should be zero, as we only reported one LUN.
        cblen=ord(cbw[14])&0x1F;
        cb=cbw[15:31];
        self.handleCB(cb,cblen,dtlen,dtdir);
        
    def handleCB(self,cb,cblen,dtlen,dtdir):
        """Handles a command block, then replies with a CSW."""
        print "Got command block 0x%02x, length %i bytes" % (
            ord(cb[0]), dtlen);
        verb=ord(cb[0]);
        status=00; #good, set to 1 for bad.
        if verb==0x00: # Test Unit Ready
            response=[0,0,0,0,0,0];
            self.writebytes(rEP3INFIFO,
                       response);
            self.wregAS(rEP3INBC,len(response));
            while not(self.rreg(rEPIRQ)&bmIN3BAVIRQ):
                #Wait for the packet to complete before sending the next.
                print "Waiting to complete inquiry."
                pass;
        elif verb==0x03: # Request Sense
            print "Responding to Request Sense.  Needed for Macs.";
            response=[0x70, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0A,
                      0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
                      0x00, 0x00,
                      0,0,0,0,0];
            status=1;
            self.writebytes(rEP3INFIFO,
                       response);
            self.wregAS(rEP3INBC,len(response));
            while not(self.rreg(rEPIRQ)&bmIN3BAVIRQ):
                #Wait for the packet to complete before sending the next.
                print "Waiting to complete inquiry."
                pass;
        elif verb==0x12: #Inquiry
            print "Responding to CB inquiry.";
            response=[
                0x00,
                0x80, # make 0x80 for removable media
                0x05, # SPC2
                0x02, # SPC2
                0x1f, #Additional length.
                0x00, 0x00, 0x00,
                #Manufacturer
                ord('G'),ord('o'),ord('o'),ord('d'),ord('F'),ord('E'),ord('T'),0,
                #Device name
                ord('G'),ord('o'),ord('o'),ord('d'),ord('F'),ord('E'),ord('T'),0,
                0,0,0,0,0,0,0,0,
                ord('0'),ord('.'),ord('0'),ord('1')]
            self.writebytes(rEP3INFIFO,
                            response);
            self.wregAS(rEP3INBC,len(response));
            while not(self.rreg(rEPIRQ)&bmIN3BAVIRQ):
                #Wait for the packet to complete before sending the next.
                print "Waiting to complete inquiry."
                pass;
        else:
            print "ERROR: Unknown command block verb %02x." % verb;
            status=1; #Command Failed
            if dtlen>0:
                print "Exiting, as %i bytes are expected to be transfered toward %i." % (
                    dtlen,dtdir);
                    
                sys.exit();
        cbw=self.lastCBW;
        
        #Now we need to send the CSW.
        csw=[
            #Standard prefix.
            ord('U'),ord('S'),ord('B'),ord('S'),
            #CBW key; must be the same as the one we're replying to.
            ord(cbw[4]),ord(cbw[5]),ord(cbw[6]),ord(cbw[7]),
            #CSW Data Residue, probably oughtn't be zeroed.
            0,0,0,
            #Status byte: 00 for good, 01 for bad.
            status];
        self.writebytes(rEP3INFIFO,
                        csw);
        self.wregAS(rEP3INBC,len(csw));
        
        
        self.wreg(rEPIRQ,bmIN3BAVIRQ); #Clear the IRQ bit.
        return;
#Initialize FET and set baud rate
client=GoodFETMAXUSBMass();
client.serInit()

client.MAXUSBsetup();
client.massinit();

