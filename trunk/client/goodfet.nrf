#!/usr/bin/env python

#GoodFET SPI Flash Client
#by Travis Goodspeed

import sys;
import binascii;
import array;
import time;

from GoodFETNRF import GoodFETNRF;
from intelhex import IntelHex;


regnames=["CONFIG","EN_AA","EN_RXADDR","SETUP_AW","SETUP_RET",
          "RF_CH","RF_SETUP","STATUS","OBSERVE_TX","RPD",
          "RX_ADDR_P0","RX_ADDR_P1","RX_ADDR_P2","RX_ADDR_P3","RX_ADDR_P4","RX_ADDR_P5",
          "TX_ADDR",
          "RX_PW_P0","RX_PW_P1","RX_PW_P2","RX_PW_P3","RX_PW_P4","RX_PW_P5",
          "FIFO_STATUS","?",
          "?","?","?","DYNPD","FEATURE","AGC_CONFIG","?","?",
          "?","?","?","?","?","?","?","?"];

def printpacket(packet):
    s="";
    i=0;
    for foo in packet:
        i=i+1;
        if i>client.packetlen: break;
        s="%s %02x" % (s,ord(foo));
    print "%s" % s;

def printconfig():
    print "Encoding %s" % client.RF_getenc();
    print "Freq    %10i MHz" % (client.RF_getfreq()/10**6);
    print "Rate    %10i kbps" % (client.RF_getrate()/1000);
    print "PacketLen %02i bytes" % client.RF_getpacketlen();
    #print "MacLen    %2i bytes" % client.RF_getmaclen();
    print "SMAC  0x%010x" % client.RF_getsmac();
    print "TMAC  0x%010x" % client.RF_gettmac();


if(len(sys.argv)==1):
    print "Usage: %s verb [objects]\n" % sys.argv[0];
    print "%s info" % sys.argv[0];
    print "%s test" % sys.argv[0];
    print "%s regs" % sys.argv[0];
    print "%s regbits" % sys.argv[0];
    print "%s pyregs" % sys.argv[0];
    print "";
    print "%s sniff\n\tSniffs packets by current config." % sys.argv[0];
    print "%s sniffob\n\tSniffs OpenBeacon traffic." % sys.argv[0];
    print "%s snifftp\n\tSniffs Turning Point Clicker traffic." % sys.argv[0];
    print "%s sniffsf\n\tSniffs SparkFun Dongle traffic." % sys.argv[0];
    print "";
    print "%s sniffprom [0xaa|0x55]\n\tSniffs promiscuously for a preamble of 0xAA or 0x55" % sys.argv[0];
    print "%s autotune\n\tSearches for a valid destination address." % sys.argv[0];
    print "";
    print "%s sniffskybrake\n\tSniffs skybrake. [broken?]" % sys.argv[0];
    print "%s sniffmskb\n\tSniffs MS KB. [broken?]" % sys.argv[0];
    
    
    print "%s hosttp\n\tHosts Turning Point Clicker traffic." % sys.argv[0];

    print "%s carrier [freq]\n\tHolds a carrier on [freq] Hz." % sys.argv[0];
    sys.exit();

#Initialize FET and set baud rate
client=GoodFETNRF();
client.serInit()

client.NRFsetup();

if(sys.argv[1]=="info"):
    printconfig();

if(sys.argv[1]=="test"):
    print "Old registers:"
    printconfig();
    
    # Set PWR_UP=1 and PRIM_RX=0 in CONFIG.
    client.poke(0x00,2);
    #Delay of 1.5ms by round-trip.
    
    print "\n\n";
    
    #Try all data rates
    for foo in [250*10**3,
                1*10**6,
                2*10**6]:
        client.RF_setrate(foo);
        if(client.RF_getrate()!=foo):
            print "ERROR Rate %i not supported.  Got %i instead." % (foo,
                                                                     client.RF_getrate());
    
    print "\n\n";
    client.poke(0x0A,0xDEADBEEF,5);
    #print "SMAC set to %010x" % client.RF_getsmac();
    if client.RF_getsmac()!=0xdeadbeef:
        print "ERROR: Failed to set MAC address.";
    print "Final registers:"
    printconfig();
    
if(sys.argv[1]=="carrier"):
    if len(sys.argv)>2:
        client.RF_setfreq(eval(sys.argv[2]));
    client.RF_carrier();
    printconfig();
    print "\nHolding a carrier wave.";
    while(1):
        time.sleep(1);
if(sys.argv[1]=="regs"):
    for r in range(0,0x20):
        print "r[0x%02x]=0x%010x //%16s " % (r,client.peek(r),regnames[r]);
if(sys.argv[1]=="pyregs"):
    for r in range(0,0x20):
        print "client.set(0x%02x,0x%010x); #%16s " % (r,client.peek(r),regnames[r]);

if(sys.argv[1]=="peek"):
    start=0x0000;
    if(len(sys.argv)>2):
        start=int(sys.argv[2],16);
    stop=start;
    if(len(sys.argv)>3):
        stop=int(sys.argv[3],16);
    print "Peeking from %02x to %02x." % (start,stop);
    while start<=stop:
        print "%02x: %010x" % (start,client.peek(start));
        start=start+1;
if(sys.argv[1]=="poke"):
    start=0x0000;
    val=0x00;
    if(len(sys.argv)>2):
        start=int(sys.argv[2],16);
    if(len(sys.argv)>3):
        val=int(sys.argv[3],16);
    print "Poking %02x to become %010x." % (start,val);
    
    client.poke(start,val);
    print "Poked to %04x" % client.peek(start);

if(sys.argv[1]=="sniffob"):
    #Reversal of transmitter code from nRF_CMD.c of OpenBeacon
    #TODO remove all poke() calls.
    
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    client.RF_setfreq(2481 * 10**6);
    client.poke(0x06,0x09); #2MBps, -18dBm in RF_SETUP
    client.poke(0x07,0x78); #Reset status register
    
    #OpenBeacon defines these in little endian as follows.
    client.RF_setmaclen(5); # SETUP_AW for 5-byte addresses.
    #0x01, 0x02, 0x03, 0x02, 0x01
    client.RF_setsmac(0x0102030201);
    #'O', 'C', 'A', 'E', 'B'
    client.RF_settmac(0x424541434F);
    
    #Set packet length of 16.
    client.RF_setpacketlen(16);
    
    #Power radio, prime for RX, one-byte checksum.
    client.poke(0x00,0x70|0x03|0x08); #0x08 for one byte, 0x04 for two.
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    #Now we're ready to get packets.
    while 1:
        packet=None;
        while packet==None:
            #time.sleep(0.1);
            packet=client.RF_rxpacket();
        printpacket(packet);
        sys.stdout.flush();

if(sys.argv[1]=="regbits"):
    print "Scanning registers to determine which bits are valid."
    regbits=range(0,0x30);
    for r in range(0,0x30):
        old=client.peek(r);
        #Which bits can be set?
        client.poke(r,0xFF);
        ones=client.peek(r);
        #Which bits can be clear?
        client.poke(r,0x00);
        zeroes=client.peek(r);
        regbits[r]=(ones & (~zeroes));
    for r in range(0,0x30):
        if regbits[r]!=0:
            print "r[0x%02x] masked %02x // %s" % (r,regbits[r], regnames[r]);
if(sys.argv[1]=="sniffprom"):
    #Reversal of transmitter code from nRF_CMD.c of OpenBeacon
    #TODO remove all poke() calls.
    
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    #client.RF_setfreq(2481 * 10**6);
    #client.poke(0x06,0x09); #2MBps, -18dBm in RF_SETUP
    client.poke(0x07,0x78); #Reset status register
    
    #OpenBeacon defines these in little endian as follows.
    client.RF_setmaclen(2); # SETUP_AW for shortest
    
    #It's better to have a known fragment, when one is available.
    #client.RF_setsmac(0x00AA);
    #client.RF_setsmac(0x0055);
    
    #Should end in 55 or AA depending upon the packet.
    tail=0x55
    if(len(sys.argv)>2):
        tail=int(sys.argv[2],16);
    else:
        print "Please specify a tail of 0xAA or 0x55.";
        sys.exit(1);
    client.RF_setsmac(tail);
    
    #Longest length.
    client.RF_setpacketlen(32);
    
    #Power radio, prime for RX, no checksum
    client.poke(0x00,0x70|0x03); #0x08 for checksum, 0x04 for two.
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    #Now we're ready to get packets.
    while 1:
        packet=None;
        while packet==None:
            #time.sleep(0.1);
            packet=client.RF_rxpacket();
        printpacket(packet);
        sys.stdout.flush();

class AutoTuner():
    """This guesses addresses by searching through packets."""
    #packets=[];
    addresses={};
    client=None;
    def init(self,goodfet):
        """Initializes a link to the GoodFET for autotuning."""
        self.client=goodfet;
    def packetaddr(self,packet):
        """Returns a loaded packet address, including channel and rate."""
        
        sync=self.client.RF_getsmac()&0xFF;
        
        mac="";
        #MAC,RF_CH,RATE
        for i in range(0,5):
            mac="%s%02x" % (mac,ord(packet[i]));
        ch=self.client.peek(0x05);
        rate=self.client.peek(0x06);
        return "%02x,%s,%02x,%02x" % (
            sync,mac,ch,rate);
    def validmac(self,packet):
        sync=self.client.RF_getsmac()&0xFF;
        if (ord(packet[0])&0x80)^(sync&0x80):
            #print "%02x%02x invalid entry." % (sync,ord(packet[0]));
            return False;
        return True;
        
    def handle(self,packet):
        """Handles a packet."""
        #printpacket(packet);
        if not self.validmac(packet):
            #print "Dropped packet:";
            #printpacket(packet);
            return;
        addr=self.packetaddr(packet);
        
        #Increment the address count.
        count=0;
        try:
            count=self.addresses[addr];
        except:
            pass;
        self.addresses[addr]=count+1;
        rate=count*1.0/len(self.addresses);
        if self.addresses[addr]>1 or rate>0.01:
            print "'%s' looks valid\t%i\t%0.5f" % (
                addr,count,rate);
        return;
    tunecount=0;
    def retune(self,freqmod=0x52):
        """Tunes to another channel or preamble looking for the next packet."""
        count=self.tunecount+1;
        self.tunecount=count;
        
        #Swap the SYNC value most often.
        sync=0xAA;
        if count&1:
            sync=0x55;
        self.client.RF_setsmac(sync);
        count=(count>>1);
        
        #Then the data rate.
        rate=0;
        
        #This swaps between 1Mbps and 2Mbps.
        #TODO add support for 256kbps, if anyone uses it.
        if count&1:
            rate=rate|0x08;
        #print "Setting rate to 0x%02x" % rate;
        if(rate==0x20):
            rate=0x08;
        self.client.poke(0x06,rate);
        count=(count>>2);
        
        #Grab two packets to clear buffers.
        #Should retune only after a few packets to reduce this delay.
        packet=client.RF_rxpacket();
        packet=client.RF_rxpacket();
        return;
        
        
if(sys.argv[1]=="autotune"):
    #Reversal of transmitter code from nRF_CMD.c of OpenBeacon
    #TODO remove all poke() calls.
    guesser=AutoTuner();
    guesser.init(client);
    
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    #client.RF_setfreq(2481 * 10**6);
    #client.poke(0x06,0x09); #2MBps, -18dBm in RF_SETUP
    client.poke(0x07,0x78); #Reset status register
    
    #OpenBeacon defines these in little endian as follows.
    client.RF_setmaclen(2); # SETUP_AW for shortest
    
    #This is determined by the MAC, which we don't yet know.
    #AutoTuner() takes care of finding it.
    #client.RF_setsmac(0x00AA);
    #client.RF_setsmac(0x0055);
    
    #Longest length.
    client.RF_setpacketlen(32);
    
    #Power radio, prime for RX, no checksum
    client.poke(0x00,0x70|0x03); #0x08 for checksum, 0x04 for two.
    
    print "Autotuning as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    print "sync,mac,r5,r6";
    #Now we're ready to get packets.
    while 1:
        for foo in range(1,10):
            packet=None;
            while packet==None:
                packet=client.RF_rxpacket();
            guesser.handle(packet);
            guesser.retune();
        sys.stdout.flush();

if(sys.argv[1]=="sniffmskb"):
    #MSWK 3000 v2.0
    #TODO remove all poke() calls.
    
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    client.poke(0x06,0x09); #2MBps, -18dBm in RF_SETUP
    client.poke(0x07,0x78); #Reset status register
    
    #This is the address of a specific keyboard.
    #Other keyboards will be different.
    
    
    client.RF_setmaclen(2);
    
    #Known pairs.  The channel and the low address bytes must match.
    #client.RF_setfreq((2400+0x13) * 10**6);
    #client.RF_setsmac(0x0c00a3598cd);
    
    client.RF_setfreq((2400+0x15) * 10**6);
    client.RF_setsmac( 0x0c10446facd);
    
    #Mac packet length, illegally 0-length address field.
    client.RF_setpacketlen(32);
    
    #Power radio, prime for RX, no checksum
    client.poke(0x00,0x70|0x03); #0x08 for checksum, 0x04 for two.
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    #Now we're ready to get packets.
    while 1:
        packet=None;
        while packet==None:
            #time.sleep(0.1);
            packet=client.RF_rxpacket();
        printpacket(packet);
        sys.stdout.flush();



if(sys.argv[1]=="sniffskybrake"):
    #Reversal of transmitter code from nRF_CMD.c of OpenBeacon
    #TODO remove all poke() calls.
    
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    client.RF_setfreq(2439 * 10**6);
    client.poke(0x06,0x00); #1MBps
    client.poke(0x07,0x78); #Reset status register
    
    #OpenBeacon defines these in little endian as follows.
    client.RF_setmaclen(2); # SETUP_AW for 3-byte addresses.
    #0x01, 0x02, 0x03, 0x02, 0x01
    
    client.RF_setsmac(0x070700d2c4); #reversed
    
    #client.RF_setsmac(0xd2c4);
    #client.RF_setsmac(0);
    
    #Mac packet length, illegally 0-length address field.
    client.RF_setpacketlen(32);
    
    #Power radio, prime for RX, one-byte checksum.
    client.poke(0x00,0x70|0x03); #0x08 for one byte, 0x04 for two.
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    print "%i byte mac match." % client.RF_getmaclen();
    #Now we're ready to get packets.
    while 1:
        packet=None;
        while packet==None:
            #time.sleep(0.1);
            packet=client.RF_rxpacket();
        printpacket(packet);
        sys.stdout.flush();

if(sys.argv[1]=="sniffsf"):
    #Reversal of transmitter code from nRF_CMD.c of OpenBeacon
    #TODO remove all poke() calls.
    
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    client.RF_setfreq(2402 * 10**6);
    client.poke(0x06,0x07); #1Mbps
    client.poke(0x07,0x78); #Reset status register
    
    #OpenBeacon defines these in little endian as follows.
    client.RF_setmaclen(5); # SETUP_AW for 5-byte addresses.
    client.RF_setsmac(0xe7e7e7e7e7);
    client.RF_settmac(0xe7e7e7e7e7);
    
    #Set packet length of 16.
    client.RF_setpacketlen(4);
    
    #Power radio, prime for RX, one-byte checksum.
    client.poke(0x00,0x70|0x03|0x08); #0x08 for one byte, 0x04 for two.
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    #Now we're ready to get packets.
    while 1:
        packet=None;
        while packet==None:
            #time.sleep(0.1);
            packet=client.RF_rxpacket();
        printpacket(packet);
        sys.stdout.flush();

if(sys.argv[1]=="snifftp"):
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    client.RF_setfreq((2400+0x29) * 10**6);
    client.poke(0x06,0x00); #1Mbps
    client.poke(0x07,0x78); #Reset status register
    
    client.RF_setmaclen(3); # SETUP_AW for 3-byte addresses.
    client.RF_setsmac(0x123456);
    client.RF_setpacketlen(4);
    
    #Power radio, prime for RX, two-byte checksum.
    client.poke(0x00,0x70|0x03|0x04|0x08);
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    #Now we're ready to get packets.
    while 1:
        packet=None;
        while packet==None:
            #time.sleep(0.1);
            packet=client.RF_rxpacket();
        printpacket(packet);
        sys.stdout.flush();

if(sys.argv[1]=="hosttp"):
    client.poke(0x00,0x00); #Stop nRF
    client.poke(0x01,0x00); #Disable Shockburst
    client.poke(0x02,0x01); #Set RX Pipe 0
    
    chan=0x29;

    client.RF_setfreq((2400+chan) * 10**6);
    client.poke(0x06,0x00); #1Mbps
    client.poke(0x07,0x78); #Reset status register
    
    client.RF_setmaclen(3); # SETUP_AW for 3-byte addresses.
    client.RF_setsmac(0x123456);
    client.RF_setpacketlen(4);
    
    #Power radio, prime for RX, two-byte checksum.
    client.poke(0x00,0x70|0x03|0x04|0x08);
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    #Now we're ready to get packets.
    while 1:
        packet=None;
        while packet==None:
            packet=client.RF_rxpacket();
        mac=((ord(packet[0])<<16)+
             (ord(packet[1])<<8)+
             ord(packet[2]));
        key=packet[3];
        print "%c from %06x" % (key,mac);
        sys.stdout.flush();

if(sys.argv[1]=="sniff"):
    #client.poke(0x00,0x00); #Stop nRF
    client.poke(0x07,0x78); #Reset status register
    
    #Power radio, prime for RX, checksum.
    client.poke(0x00,0x70|0x03|0x08);
    
    print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                           client.RF_getfreq()/10**6);
    #Now we're ready to get packets.
    
    while 1:
        packet=None;
        while packet==None:
            #time.sleep(0.1);
            packet=client.RF_rxpacket();
        printpacket(packet);
        sys.stdout.flush();
if(sys.argv[1]=="explore"):
    #client.poke(0x00,0x00); #Stop nRF
    client.poke(0x07,0x78); #Reset status register
    
    #Power radio, prime for RX, no checksum.
    client.poke(0x00,0x70|0x03);
    
    #Set packet length of 32.
    #Without checksums, extra data will mix in.
    client.RF_setpacketlen(32);
    client.RF_setmaclen(3); # shortest address length
    
    #Now we're ready to get packets.
    for smac in [0x0102030201, 0]:
        client.RF_setsmac(smac);
        for chan in range(0,0x80):
            client.RF_setfreq((2400+chan) * 10**6);
            time.sleep(1);
            packet=client.RF_rxpacket();
            if packet!=None:
                print "Listening as %010x on %i MHz" % (client.RF_getsmac(),
                                                        client.RF_getfreq()/10**6);
                printpacket(packet);
                sys.stdout.flush();
